#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jul 15 16:52:58 2024

@author: hpc
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.metrics import accuracy_score, classification_report
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Conv1D, MaxPooling1D, Flatten, LSTM, Bidirectional, SimpleRNN
import matplotlib.pyplot as plt

# Load data
csv_file = '/home/hpc/Desktop/finalfeatures.csv'
df = pd.read_csv(csv_file)

# Filter data for 'Scareware' and 'Backdoor'
df_filtered = df[df['Category'].isin(['Scareware', 'Backdoor'])]

# Encode labels
label_encoder = LabelEncoder()
df_filtered['Category'] = label_encoder.fit_transform(df_filtered['Category'])

# Separate features and labels
X = df_filtered.drop(['Category'], axis=1)
y = df_filtered['Category']

# Normalize features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

# Define DL models
models = {
    'MLP': Sequential([
        Dense(128, activation='relu', input_shape=(X_train.shape[1],)),
        Dropout(0.5),
        Dense(64, activation='relu'),
        Dense(1, activation='sigmoid')
    ]),
    'CNN': Sequential([
        Conv1D(filters=64, kernel_size=3, activation='relu', input_shape=(X_train.shape[1], 1)),
        MaxPooling1D(pool_size=2),
        Flatten(),
        Dense(1, activation='sigmoid')
    ]),
    'RNN': Sequential([
        SimpleRNN(64, input_shape=(X_train.shape[1], 1)),
        Dense(1, activation='sigmoid')
    ]),
    'LSTM': Sequential([
        LSTM(64, input_shape=(X_train.shape[1], 1)),
        Dense(1, activation='sigmoid')
    ]),
    'Bidirectional LSTM': Sequential([
        Bidirectional(LSTM(64), input_shape=(X_train.shape[1], 1)),
        Dense(1, activation='sigmoid')
    ])
}

# Dictionary to store accuracies for each model
model_accuracies = {}

# Train and evaluate each DL model
for model_name, model in models.items():
    print(f"Training {model_name}...")
    
    # Reshape input data for models that require 3D input (e.g., CNN, RNN, LSTM)
    if 'CNN' in model_name or 'RNN' in model_name or 'LSTM' in model_name or 'Bidirectional LSTM' in model_name:
        X_train_3d = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)
        X_test_3d = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)
        model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
        model.fit(X_train_3d, y_train, epochs=80, batch_size=32, verbose=0)
        y_pred_proba = model.predict(X_test_3d)
    else:
        model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
        model.fit(X_train, y_train, epochs=80, batch_size=32, verbose=0)
        y_pred_proba = model.predict(X_test)
    
    # Convert probabilities to class labels
    y_pred = (y_pred_proba > 0.5).astype(int)
    
    # Evaluate the model
    accuracy = accuracy_score(y_test, y_pred)
    model_accuracies[model_name] = accuracy
    report = classification_report(y_test, y_pred, target_names=label_encoder.classes_)
    
    print(f"{model_name} Accuracy: {accuracy}")
    print(f"Classification Report for {model_name}:\n{report}\n")
# Plotting accuracies
plt.figure(figsize=(10, 6))
# Define colors for each model
colors = ['blue', 'green', 'red', 'purple', 'orange']

# Plot bars with different colors
bars = plt.bar(model_accuracies.keys(), model_accuracies.values(), color=colors)

plt.xlabel('Models')
plt.ylabel('Accuracy')
plt.title('Accuracy of Different DL Models')
plt.ylim(0, 1.2)  # Assuming accuracy ranges from 0 to 1
plt.xticks(rotation=45)
# Annotate each bar with its accuracy value
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, yval, round(yval, 3), ha='center', va='bottom', fontsize=8)

plt.tight_layout()
plt.show()

print("Training and evaluation completed for all DL models.")
